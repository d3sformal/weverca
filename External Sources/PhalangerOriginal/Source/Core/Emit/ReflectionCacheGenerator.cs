/*

 Copyright (c) 2004-2006 Tomas Matousek.

 The use and distribution terms for this software are contained in the file named License.txt, 
 which can be found in the root of the Phalanger distribution. By using this software 
 in any fashion, you are agreeing to be bound by the terms of this license.
 
 You must not remove this notice from this software.

*/

using System;
using System.Reflection;
using System.Threading;
using System.Text;
using System.Collections;
using PHP.Core;

#if SILVERLIGHT
using PHP.CoreCLR;
#endif

namespace PHP.Core.Emit
{
#if DEBUG

	public class MethodsGenerator
	{
		private static void GenerateParams(MethodInfo m, out string params1, out string params2)
		{
			StringBuilder ps1 = new StringBuilder();
			StringBuilder ps2 = new StringBuilder();

			int i = 0;
			foreach (ParameterInfo p in m.GetParameters())
			{
				if (i > 0)
				{
					ps1.Append('_');
					ps2.Append(',');
				}
				if (p.ParameterType.IsByRef)
				{
					ps1.AppendFormat("{0}Ref", p.ParameterType.GetElementType().Name);
					ps2.AppendFormat("Type.GetType(\"{0}\") ", p.ParameterType.FullName);
				}
				else
					if (p.ParameterType.IsArray)
					{
						ps1.AppendFormat("{0}Array", p.ParameterType.GetElementType().Name);
						ps2.AppendFormat("typeof({0})", p.ParameterType.Name);
					}
					else
					{
						ps1.Append(p.ParameterType.Name);
						ps2.AppendFormat("typeof({0})", p.ParameterType.Name);
					}
				i++;
			}

			params1 = ps1.ToString();
			params2 = ps2.ToString();
		}

		public static Hashtable GetOverloadCounts(MethodInfo[] methods)
		{
			Hashtable result = new Hashtable();
			foreach (MethodInfo m in methods)
			{
				result[m.Name] = (result[m.Name] == null) ? 1 : result[m.Name] = (int)result[m.Name] + 1;
			}
			return result;
		}

		public static void Generate(Type type, BindingFlags binding)
		{
			Console.WriteLine("// automatically generated by MethodsGenerator:");
			Console.WriteLine("public struct {0}", type.Name);
			Console.WriteLine("{");
            Console.WriteLine("  static Type _this { get { return typeof({0}); } }", type.FullName);

			Console.Write("  static MethodInfo ");

			MethodInfo[] methods = type.GetMethods(binding);
			Hashtable ht = GetOverloadCounts(methods);

			// private fields:
			int i = 0;
			foreach (MethodInfo m in methods)
			{
				if ((int)ht[m.Name] == 1)
				{
					if (i > 0) Console.Write(',');
					i++;
					Console.Write('_');
					Console.Write(m.Name);
				}
			}
			Console.WriteLine(";");
			Console.WriteLine();

			// methods or structures of overloads:
			int k = 0;
			while (k < methods.Length)
			{
				MethodInfo m = methods[k];

				if ((int)ht[m.Name] == 1)
				{
					Console.WriteLine("  public static MethodInfo {0} {{ get {{ return _{0} ?? (_{0} = _this.GetMethod(\"{0}\")); }} }}", m.Name);
					k++;
				}
				else
				{
					int overload_count = (int)ht[m.Name];

					Console.WriteLine("  public struct {0}", m.Name);
					Console.WriteLine("  {");

					Console.Write("    static MethodInfo ");
					i = 0;
					for (int j = 0; j < overload_count; j++)
					{
						string ps1, ps2;
						GenerateParams(methods[k + j], out ps1, out ps2);
						if (i > 0) Console.Write(',');
						Console.Write('_');
						Console.Write(ps1);
						i++;
					}
					Console.WriteLine(';');
					Console.WriteLine();

					for (int j = 0; j < overload_count; j++)
					{
						string ps1, ps2;
						GenerateParams(methods[k + j], out ps1, out ps2);

						Console.WriteLine(
						  "    public static MethodInfo {1} {{ get {{ return _{1} ?? (_{1} = _this.GetMethod(\"{0}\", new Type[] {{{2}}})); }} }}",
						  m.Name, ps1, ps2);
					}

					Console.WriteLine("  }");
					Console.WriteLine();

					k += overload_count;
				}
			}
			Console.WriteLine("}");

		}
	}

#endif
}
