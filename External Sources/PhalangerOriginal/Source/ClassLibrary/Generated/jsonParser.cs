// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, QUT 2005
// (see accompanying GPPGcopyright.rtf)


using System;
using System.Text;
using System.Collections.Generic;

using PHP.Core;
using PHP.Core.Parsers.GPPG;
using System.Diagnostics;


namespace PHP.Library.Json
{
public enum Tokens {ERROR=1,EOF=2,ARRAY_OPEN=3,ARRAY_CLOSE=4,ITEMS_SEPARATOR=5,NAMEVALUE_SEPARATOR=6,OBJECT_OPEN=7,OBJECT_CLOSE=8,TRUE=9,FALSE=10,NULL=11,INTEGER=12,DOUBLE=13,STRING=14,STRING_BEGIN=15,CHARS=16,UNICODECHAR=17,ESCAPEDCHAR=18,STRING_END=19};

public partial struct SemanticValueType
{
	public object obj; 
}
public partial struct Position
{
  public int FirstLine;
  public int FirstColumn;
  public int FirstOffset;
  public int LastLine;
  public int LastColumn;
  public int LastOffset;

  public Position(int firstLine, int firstColumn, int firstOffset, int lastLine, int lastColumn, int lastOffset)
  {
    this.FirstLine = firstLine;
    this.FirstColumn = firstColumn;
    this.FirstOffset = firstOffset;
    this.LastLine = lastLine;
    this.LastColumn = lastColumn;
    this.LastOffset = lastOffset;
  }
}
public  partial class Parser: ShiftReduceParser<SemanticValueType,Position>
{

  protected override string[] NonTerminals { get { return nonTerminals; } }
  private static string[] nonTerminals;

  protected override State[] States { get { return states; } }
  private static State[] states;

  protected override Rule[] Rules { get { return rules; } }
  private static Rule[] rules;

  protected sealed override Position CombinePositions(Position first, Position last)
  {
    return new Position(first.FirstLine, first.FirstColumn, first.FirstOffset, last.LastLine, last.LastColumn, last.LastOffset);
  }

  #region Construction

  static Parser()
  {

    states = new State[]
    {
      new State(0, new int[] {14,4,12,5,13,6,7,8,3,19,9,26,10,27,11,28}, new int[] {-1,1,-3,3,-4,7,-7,18}),
      new State(1, new int[] {2,2}),
      new State(2, -1),
      new State(3, -2),
      new State(4, -12),
      new State(5, -13),
      new State(6, -14),
      new State(7, -15),
      new State(8, new int[] {8,11,14,15}, new int[] {-5,9,-6,12}),
      new State(9, new int[] {8,10}),
      new State(10, -3),
      new State(11, -4),
      new State(12, new int[] {5,13,8,-6}),
      new State(13, new int[] {14,15}, new int[] {-5,14,-6,12}),
      new State(14, -5),
      new State(15, new int[] {6,16}),
      new State(16, new int[] {14,4,12,5,13,6,7,8,3,19,9,26,10,27,11,28}, new int[] {-3,17,-4,7,-7,18}),
      new State(17, -7),
      new State(18, -16),
      new State(19, new int[] {4,22,14,4,12,5,13,6,7,8,3,19,9,26,10,27,11,28}, new int[] {-8,20,-3,23,-4,7,-7,18}),
      new State(20, new int[] {4,21}),
      new State(21, -8),
      new State(22, -9),
      new State(23, new int[] {5,24,4,-11}),
      new State(24, new int[] {14,4,12,5,13,6,7,8,3,19,9,26,10,27,11,28}, new int[] {-8,25,-3,23,-4,7,-7,18}),
      new State(25, -10),
      new State(26, -17),
      new State(27, -18),
      new State(28, -19),
    };

    rules = new Rule[20];
    rules[1]=new Rule(-2, new int[]{-1,2});
    rules[2]=new Rule(-1, new int[]{-3});
    rules[3]=new Rule(-4, new int[]{7,-5,8});
    rules[4]=new Rule(-4, new int[]{7,8});
    rules[5]=new Rule(-5, new int[]{-6,5,-5});
    rules[6]=new Rule(-5, new int[]{-6});
    rules[7]=new Rule(-6, new int[]{14,6,-3});
    rules[8]=new Rule(-7, new int[]{3,-8,4});
    rules[9]=new Rule(-7, new int[]{3,4});
    rules[10]=new Rule(-8, new int[]{-3,5,-8});
    rules[11]=new Rule(-8, new int[]{-3});
    rules[12]=new Rule(-3, new int[]{14});
    rules[13]=new Rule(-3, new int[]{12});
    rules[14]=new Rule(-3, new int[]{13});
    rules[15]=new Rule(-3, new int[]{-4});
    rules[16]=new Rule(-3, new int[]{-7});
    rules[17]=new Rule(-3, new int[]{9});
    rules[18]=new Rule(-3, new int[]{10});
    rules[19]=new Rule(-3, new int[]{11});

    nonTerminals = new string[] {"", "start", "$accept", "value", "object", 
      "members", "pair", "array", "elements", };
  }

  #endregion

  protected override void DoAction(int action)
  {
    switch (action)
    {
      case 2: // start -> value 
{ Result = value_stack.array[value_stack.top-1].yyval.obj; }
        return;
      case 3: // object -> OBJECT_OPEN members OBJECT_CLOSE 
{
			var elements = (List<KeyValuePair<string, object>>)value_stack.array[value_stack.top-2].yyval.obj;
				
			if (decodeOptions.Assoc)
			{
				var arr = new PhpArray( elements.Count );
				
				foreach (var item in elements)
					arr.Add( PHP.Core.Convert.StringToArrayKey(item.Key), item.Value );
					
				yyval.obj = arr;
			}
			else
			{
				var std = new stdClass(context, true);
				std.AddRange( elements );
				yyval.obj = std;
			}
		}
        return;
      case 4: // object -> OBJECT_OPEN OBJECT_CLOSE 
{ yyval.obj = new stdClass(context, true); }
        return;
      case 5: // members -> pair ITEMS_SEPARATOR members 
{
			var elements = (List<KeyValuePair<string, object>>)value_stack.array[value_stack.top-1].yyval.obj;
			var result = new List<KeyValuePair<string, object>>( elements.Count + 1 ){ (KeyValuePair<string,object>)value_stack.array[value_stack.top-3].yyval.obj };
			result.AddRange(elements);			
			yyval.obj = result;
		}
        return;
      case 6: // members -> pair 
{ yyval.obj = new List<KeyValuePair<string, object>>(){ (KeyValuePair<string,object>)value_stack.array[value_stack.top-1].yyval.obj }; }
        return;
      case 7: // pair -> STRING NAMEVALUE_SEPARATOR value 
{ yyval.obj = new KeyValuePair<string,object>((string)value_stack.array[value_stack.top-3].yyval.obj, value_stack.array[value_stack.top-1].yyval.obj); }
        return;
      case 8: // array -> ARRAY_OPEN elements ARRAY_CLOSE 
{
			var elements = (List<object>)value_stack.array[value_stack.top-2].yyval.obj;
			var arr = new PhpArray( elements.Count );
			
			foreach (var item in elements)
				arr.Add( item );
				
			yyval.obj = arr;
		}
        return;
      case 9: // array -> ARRAY_OPEN ARRAY_CLOSE 
{ yyval.obj = new PhpArray(); }
        return;
      case 10: // elements -> value ITEMS_SEPARATOR elements 
{
			var elements = (List<object>)value_stack.array[value_stack.top-1].yyval.obj;
			var result = new List<object>( elements.Count + 1 ){ value_stack.array[value_stack.top-3].yyval.obj };
			result.AddRange(elements);			
			yyval.obj = result;
		}
        return;
      case 11: // elements -> value 
{ yyval.obj = new List<object>(){ value_stack.array[value_stack.top-1].yyval.obj }; }
        return;
      case 12: // value -> STRING 
{yyval.obj = value_stack.array[value_stack.top-1].yyval.obj;}
        return;
      case 13: // value -> INTEGER 
{yyval.obj = value_stack.array[value_stack.top-1].yyval.obj;}
        return;
      case 14: // value -> DOUBLE 
{yyval.obj = value_stack.array[value_stack.top-1].yyval.obj;}
        return;
      case 15: // value -> object 
{yyval.obj = value_stack.array[value_stack.top-1].yyval.obj;}
        return;
      case 16: // value -> array 
{yyval.obj = value_stack.array[value_stack.top-1].yyval.obj;}
        return;
      case 17: // value -> TRUE 
{yyval.obj = true;}
        return;
      case 18: // value -> FALSE 
{yyval.obj = false;}
        return;
      case 19: // value -> NULL 
{yyval.obj = null;}
        return;
    }
  }

  protected override string TerminalToString(int terminal)
  {
    if (((Tokens)terminal).ToString() != terminal.ToString())
      return ((Tokens)terminal).ToString();
    else
      return CharToString((char)terminal);
  }



protected override int EofToken { get { return (int)Tokens.EOF; } }
protected override int ErrorToken { get { return (int)Tokens.ERROR; } }

private readonly ScriptContext/*!*/context;
private readonly PHP.Library.JsonFormatter.DecodeOptions/*!*/decodeOptions;

public Parser(ScriptContext/*!*/context, PHP.Library.JsonFormatter.DecodeOptions/*!*/decodeOptions)
{
	System.Diagnostics.Debug.Assert(context != null && decodeOptions != null);
	
	this.context = context;
	this.decodeOptions = decodeOptions;
}

public object Result{get;private set;}
}
}
